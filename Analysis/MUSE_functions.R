##*****************************************##
## Analysis of MUSE-SAP study            ####
## James Liley                             ##
## 26 October 2022                         ##
## Auxiliary functions                     ##
##*****************************************##
## 

##*****************************************##
## Packages and scripts                  ####
##*****************************************##

# Packags
library(lme4) # Linear mixed models
library(readxl) # Read excel files




##' @name rsm
##' @description Function implementing row-sums-with-missingness.
##' 
##' As per SAP, item sums are recorded as NA if >10% of items are missing. 
##' 
##' If <10% of items are missing, the missing values are replaced with the 
##'  mean of non-missing values across all other samples.
##'  
##' If all values are missing for a sample, returns all NA.
##' 
##' @param mat matrix for which row sums are to be obtained
##' @param sf36 if TRUE, take average and allow NAs
##' @return row sums or NA
rsm=function(mat,sf36=FALSE) {
  
  # Matrix with imputed values
  imp=mat
  for (j in 1:ncol(mat)) {
    z=mat[,j]
    m=mean(z,na.rm=T)
    z[which(is.na(z))]=m
    mat[,j]=z
  }
  
  # Missingness
  mnp=rowSums(is.na(mat))/ncol(mat) # Proportion of missing values
  
  # Return
  if (sf36) {
    rsum=rowMeans(imp,na.rm=TRUE)
  } else {
    rsum=rowSums(imp)
    rsum[which(mnp>0.1)]=NA
  }
  return(rsum)
}



##' @name ngen
##' @description Simulate data under an ANCOVA model as specified in SAP. Parameters are as follows:
##' beta_0: global mean outcome value
##' beta_a1: coefficient of time 1; set to 0
##' beta_a2: coefficient of time 2
##' beta_a3: coefficient of time 3
##' beta_2: coefficient of cross term (time==2)*treated (main object of inference)
##' beta_3: coefficient of cross term (time==3)*treated
##' beta: coefficient of site = 2 
##' sigma_r: standard deviation of random effect for individuals
##' sigma_e: standard deviation of random error
##' 
##' @param n number of sites per arm
##' @param par parameters of model in order above
##' @return design matrix with columns id, time, treat, site, Y, treat_time2, treat_time3
ngen=function(n,par) {
  
  # Get parameters
  par=as.list(par)
  names(par)=c("beta_0","beta_a1","beta_a2","beta_a3","beta_2","beta_3","beta","sigma_r","sigma_e")
  
  # ID, time
  inds=rep(1:(2*n),3)
  tt=c(rep(1,2*n),rep(2,2*n),rep(3,2*n)) # time
  
  # Treatment
  u0=c(rep(0,n),rep(1,n))
  u=rep(u0,3)
  
  # Random individual effect
  gamma0=rnorm(2*n,sd=par$sigma_r)
  gamma=rep(gamma0,3)
  
  # Site
  site0=sample(0:1,2*n,rep=TRUE)
  site=rep(site0,3)
  
  # Random error
  eps=rnorm(3*2*n,sd=par$sigma_e)
  
  # Generate outcome
  yit=par$beta_0 + 
    par$beta_a1*(tt==1) + 
    (par$beta_a2 + par$beta_2*u)*(tt==2) + 
    (par$beta_a3 + par$beta_3*u)*(tt==3) + 
    site*par$beta +
    gamma + eps
  
  # Collate variables
  dat=data.frame(id=inds,time=as.factor(tt),treat=u,site=site,Y=yit)
  
  # Add cross terms
  dat$treat_time2=dat$treat*(dat$time==2)
  dat$treat_time3=dat$treat*(dat$time==3)
  
  # Return
  return(dat)
}



##' @name infer_b2
##' @description Perform inference for beta_2 (effect of treatment at 8 weeks) on a dataset 
##'  generated by ngen
##' @param dat dataset as per that generated by ngen
##' @return p-value against null hypothesis beta_2=0, using likelihood ratio test
infer_b2=function(dat) {
  
  # Fit full model and null model
  xlme=lmer(Y~time + treat_time2 + treat_time3 + site + (1|id),data=dat,REML = FALSE)
  xlme0=lmer(Y~time + treat_time3 + site + (1|id),data=dat,REML = FALSE)
  
  # P-value from likelihood ratio test
  pval=as.data.frame(anova(xlme,xlme0))[2,8]

  # Return
  return(pval)

}



##' @name muse_format
##' @description Format a vector of values for tabular output. Prints mean/median, SD/IQR, and missingness.
muse_format=function(vx,type="real",dig=4) {
  if (type=="real") { # Real-valued
    miss=length(which(!is.finite(vx)))/length(vx)
    mu=mean(vx,na.rm=T)
    sig=sd(vx,na.rm=T)
    outstr=paste0(signif(mu,digits=dig),
                  " (",signif(sig,digits=dig),")")
    if (miss>0) outstr=paste0(outstr, "; ",
                  "m. ",round(100*miss),"%  ")
  }
  if (type=="count") { # count
    miss=length(which(!is.finite(vx)))/length(vx)
    med=median(vx,na.rm=T)
    iqrn=IQR(vx,na.rm=T)
    outstr=paste0(signif(med,digits=dig),
                  " (",signif(iqrn,digits=dig),")")
    if (miss>0) outstr=paste0(outstr, "; ",
                              "m. ",round(100*miss),"%  ")
  }
  if (type=="binary") { # binary
    miss=length(which(!is.finite(vx)))/length(vx)
    outstr=paste0(sum(vx,na.rm=T),"/",length(vx))
    if (miss>0) outstr=paste0(outstr, "; ",
                              "m. ",round(100*miss),"%  ")
  }
  if (all(is.na(vx))) outstr="NA"
  
  return(outstr)
}

#' @name msd
#' @description print mean (SD)
msd=function(x) paste0(signif(mean(x,na.rm=T),digits=ndig)," (",
                       signif(sd(x,na.rm=T),digits=ndig),")")

#' @name msdd
#' @description print mean (SD) for difference of two means
msdd=function(d1,d2,n1,n2) 
  paste0(signif(mean(d1,na.rm=T)-mean(d2,na.rm=T),digits=ndig)," (",
         signif(sqrt(var(d1,na.rm=T)/length(which(is.finite(d1))) + 
                       var(d2,na.rm=T)/length(which(is.finite(d2)))),
                digits=ndig),")")

#' @name difci
#' @description print mean (95CI) for difference of two means
difci=function(d1,d2,n1,n2,ci=0.95) {
  se=sqrt(var(d1)/n1 + var(d2)/n2)
  df=mean(d1)-mean(d2)
  q=-qnorm((1-ci)/2)
  paste0(signif(df,digits=ndig)," (",
         signif(df-q*se,digits=ndig),", ",signif(df + q*se,digits=ndig),")")
}


##' @name anygrepl
##' @description Quick auxiliary function to test if any element of a set of strings occurs
##'  in each of a second list of strings.
##' @param strs list of strings to search for e.g. c("auditory","Auditory")
##' @param check list of strings to check e.g. c("N/A","auditory,somatic","somatic")
##' @param miss list of 'missing' codes; return NA if any of these
##' @return a vector with ith element 1 if any of strs occur in check[i]
anygrepl=function(strs,check,miss="999") {
  out=rep(FALSE,length(check)) 
  for (i in 1:length(strs)) out= (out | grepl(strs[i],check))
  out[which(check %in% miss)]=NA
  return(out)
}

##' @name muse_forest
##' @description Produces a 'forest' plot of estimated effects of various factors on an outcome
##' @param tab a table with column names 'Estimate', 'CI95_lower', 'CI95_upper', and 'Description', row names as per parameter tables
##' @return NULL
muse_forest=function(tab) {
  
  par(mar=c(4,6,1,1))
  axcex=0.5

  ci_range=tab[c("βa2", "βa3", "β2", "β3", "β"),c("CI95_lower","CI95_upper")]
  mci=max(abs(ci_range))
  
  # Set up
  plot(0,type="n",xlim=c(-mci,mci),ylim=c(0.5,8.5),bty="n",
       xlab="Effect on outcome",ylab="",yaxt="n",cex.axis=axcex,cex.lab=axcex)
  abline(v=0,lty=2)
  
  dwidth=0.2; gheight=0.5
  diamond=function(i,x,col="black") {
    mid=x[1]; low=x[2]; high=x[3];
    polygon(c(low,mid,high,mid,low),i+c(0,dwidth,0,-dwidth,0),border=NA,col=col)
  }
  gauss=function(i,mu,std,col="black") {
    xx=seq(-mci,mci,length=200)
    polygon(xx,i+ (gheight/dnorm(0,sd=std))*dnorm(xx,mean=mu,sd=std),border=NA,col=col)
  }
  
  diamond(8,tab["β2",c("Estimate","CI95_lower","CI95_upper")],col="red")
  diamond(7,tab["β3",c("Estimate","CI95_lower","CI95_upper")],col="red")
  diamond(6,tab["β",c("Estimate","CI95_lower","CI95_upper")],col="black")
  diamond(5,tab["βa2",c("Estimate","CI95_lower","CI95_upper")],col="black")
  diamond(4,tab["βa3",c("Estimate","CI95_lower","CI95_upper")],col="black")
  abline(h=3) 
  gauss(2,0,tab["σr","Estimate"],col="gray")
  gauss(1,0,tab["σe","Estimate"],col="gray")

  labels1=c("Group 2, 8 week","Group 2, 12 week","Site 2","8 week","12 week","Per-individual variation","Residual variation")
  labels2=tab[c("β2",
                "β3",
                "β",
                "βa2",
                "βa3",
                "σr",
                "σe"),"Description"]
    
  axis(2,at=c(8,7,6,5,4,2,1),
       labels=labels1,
       las=2,tick=FALSE,cex.axis=axcex)  
}





##' @name pcheck
##' @description Short auxiliary function to empirically check power at particular size
##' @param size compute power at this sample size (per group)
##' @param npower number of trials 
##' @param muse_power_par parameter vector, passed to ngen()
##' @param alpha type 1 error rate
##' @return estimate of power with given parameters
pcheck=function(size,npower,muse_power_par,alpha) {
  tot=rep(0,npower)
  for (j in 1:npower) tot[j]=suppressMessages(
    suppressWarnings(
      infer_b2(ngen(size,par=muse_power_par))))
  cat(paste0("Computed power at sample size: ",size,"\n"))
  return(length(which(tot<alpha))/npower)
}


